<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>立方体：角が取れつつ一方向に永久回転</title>
<style>
  :root{
    --bg:#0b1020;
    --top:#8fc9ff;
    --side1:#5d96f0;
    --side2:#3a67b8;
    --edge:#1b274a;
    --floor:#0e1530;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#eaf1ff;font-family:system-ui, -apple-system, "Segoe UI", Roboto;}
  header{position:fixed;left:0;right:0;top:0;padding:10px 16px;background:linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,0));pointer-events:none}
  .wrap{display:grid;place-items:center;height:100%;}
  svg{width:min(92vw,720px);height:min(92vh,520px);overflow:visible}
  .hint{position:fixed;bottom:10px;left:0;right:0;display:flex;justify-content:center;gap:16px;opacity:.85}
  .panel{background:#101938;border:1px solid #1b2855;border-radius:10px;padding:8px 12px}
  a, a:visited{color:#9dc1ff}
  .soft-shadow{filter:drop-shadow(0 12px 16px rgba(0,0,0,.35)) drop-shadow(0 2px 6px rgba(0,0,0,.25));}
  .floor{opacity:.22}
</style>
</head>
<body>
<header>
  <strong>立方体：角が取れつつ一方向に永久回転（Z軸）</strong>
</header>

<div class="wrap">
  <svg id="stage" viewBox="-400 -320 800 640" aria-label="isometric spinning chamfered cube">
    <ellipse class="floor" cx="0" cy="120" rx="250" ry="70" fill="url(#floorGrad)"></ellipse>

    <g id="prism" class="soft-shadow">
      <polygon id="sideB" fill="var(--side2)" stroke="var(--edge)" stroke-width="2" />
      <polygon id="sideA" fill="var(--side1)" stroke="var(--edge)" stroke-width="2" />
      <polygon id="top"   fill="var(--top)"   stroke="var(--edge)" stroke-width="2" />
      <polyline id="topEdge" fill="none" stroke="rgba(255,255,255,.35)" stroke-width="1.3" />
    </g>

    <defs>
      <radialGradient id="floorGrad">
        <stop offset="0" stop-color="var(--floor)" stop-opacity="1"/>
        <stop offset="1" stop-color="var(--floor)" stop-opacity="0"/>
      </radialGradient>
    </defs>
  </svg>
</div>

<div class="hint">
  <div class="panel">常に同方向へ回転</div>
  <div class="panel">回転速度：<code>cfg.degPerSec</code> ／ 角取り周期：<code>cfg.chamferPeriod</code></div>
</div>

<script>
const cfg = {
  // 立方体サイズ（X=Y=Z）
  size: { X: 140, Y: 140, Z: 140 },
  shade: { top: 1.00, sideA: 0.90, sideB: 0.78 },
  chamferMaxRatio: 0.48,   // 0〜0.5
  // アニメ挙動
  degPerSec: 30,           // 一方向回転の速度（度/秒）
  chamferPeriod: 2.8,      // 角取りが 0→最大→0 する周期（秒）
};

// 等角投影
const COS30 = Math.cos(Math.PI/6), SIN30 = Math.sin(Math.PI/6);
function project(x,y,z){ return [ (x-y)*COS30, (x+y)*SIN30 - z ]; }

// 角を削った正方形（上面）
function chamferedSquare(ax, cham){
  const c = Math.max(0, Math.min(cham, ax));
  return [
    [ ax - c,  ax], [ ax,  ax - c],
    [ ax, -ax + c], [ ax - c, -ax],
    [-ax + c, -ax], [-ax, -ax + c],
    [-ax,  ax - c], [-ax + c,  ax]
  ];
}

// 菱形
function diamond(ax){ return [ [0, ax], [ ax, 0], [0, -ax], [-ax, 0] ]; }

// 周長サンプリング補間（8頂点へ）
function lerpPolys(polyA, polyB, t, samples=8){
  const out = [];
  for(let i=0;i<samples;i++){
    const pa = samplePolygon(polyA, i/samples);
    const pb = samplePolygon(polyB, i/samples);
    out.push([ pa[0]*(1-t)+pb[0]*t, pa[1]*(1-t)+pb[1]*t ]);
  }
  return out;
}
function samplePolygon(poly, u){
  const pts = poly.slice();
  if(pts.length===0) return [0,0];
  if(pts[0][0]!==pts.at(-1)[0] || pts[0][1]!==pts.at(-1)[1]) pts.push(pts[0]);
  let L=0, segs=[];
  for(let i=0;i<pts.length-1;i++){
    const dx=pts[i+1][0]-pts[i][0], dy=pts[i+1][1]-pts[i][1], l=Math.hypot(dx,dy);
    L+=l; segs.push({i,l});
  }
  let d=u*L;
  for(const s of segs){
    const a=pts[s.i], b=pts[s.i+1];
    if(d<=s.l){ const r=s.l?d/s.l:0; return [ a[0]+(b[0]-a[0])*r, a[1]+(b[1]-a[1])*r ]; }
    d-=s.l;
  }
  return pts[0];
}

// 2D回転（Z軸周り）
function rotate2D([x,y], rad){ const c=Math.cos(rad), s=Math.sin(rad); return [ x*c - y*s, x*s + y*c ]; }

// DOM
const topPoly  = document.getElementById('top');
const sideAPoly= document.getElementById('sideA');
const sideBPoly= document.getElementById('sideB');
const topEdge  = document.getElementById('topEdge');

// 簡易ライティング（色を乗算）
function shadeColor(hex, f){
  const m = hex.match(/^#?([0-9a-f]{6})$/i);
  if(!m) return hex;
  const n = parseInt(m[1],16);
  let r=(n>>16)&255, g=(n>>8)&255, b=n&255;
  r=Math.round(r*f); g=Math.round(g*f); b=Math.round(b*f);
  return `rgb(${r},${g},${b})`;
}
function getCssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
(function setFills(){
  topPoly.style.fill   = shadeColor(getCssVar('--top'),  cfg.shade.top);
  sideAPoly.style.fill = shadeColor(getCssVar('--side1'),cfg.shade.sideA);
  sideBPoly.style.fill = shadeColor(getCssVar('--side2'),cfg.shade.sideB);
})();

// 時間管理
let t0 = performance.now();
function ease01cos(t){ // 0..1..0 を滑らかに作る（コサイン）
  return 0.5 * (1 - Math.cos(2*Math.PI * t));
}

function animate(now){
  const elapsed = (now - t0)/1000;

  // 一方向回転：deg は単調増加（レンダリングでは %360 してOK）
  const deg = (elapsed * cfg.degPerSec) % 360;

  // 角取り＆菱形化：0→1→0 を周期的に
  const u = ease01cos((elapsed / cfg.chamferPeriod) % 1);

  // パラメータ生成
  const a = cfg.size.X/2;
  const H = cfg.size.Z;
  const cham = a * cfg.chamferMaxRatio * u; // 0〜max
  const morph = u;                            // 正方形→菱形→正方形
  const rad = deg * Math.PI / 180;            // 回転（一定速度・一方向）

  // 形生成
  const base = chamferedSquare(a, cham);
  const dia  = diamond(a);
  const face2D = lerpPolys(base, dia, morph, 8).map(p => rotate2D(p, rad));

  // 上下の面（Z=0, -H）
  const topPts = face2D.map(([x,y]) => project(x,y, 0));
  const botPts = face2D.map(([x,y]) => project(x,y,-H));

  // 可視側面の簡易判定
  const edges = [];
  for(let i=0;i<face2D.length;i++){
    const a2 = face2D[i], b2 = face2D[(i+1)%face2D.length];
    const mid=[(a2[0]+b2[0])/2,(a2[1]+b2[1])/2];
    edges.push({i: i, mid});
  }
  edges.sort((e1,e2)=> e2.mid[0]-e1.mid[0]); const rightEdge = edges[0];
  edges.sort((e1,e2)=> e2.mid[1]-e1.mid[1]); const backEdge  = edges[0];

  const toStr = pts => pts.map(p=>`${p[0].toFixed(1)},${p[1].toFixed(1)}`).join(' ');

  topPoly.setAttribute('points', toStr(topPts));
  topEdge.setAttribute('points', toStr(topPts.concat([topPts[0]])));

  // 側面A（右）
  {
    const i=rightEdge.i;
    const p1=topPts[i], p2=topPts[(i+1)%topPts.length], p3=botPts[(i+1)%botPts.length], p4=botPts[i];
    sideAPoly.setAttribute('points', toStr([p1,p2,p3,p4]));
  }
  // 側面B（奥）
  {
    const i=backEdge.i;
    const p1=topPts[i], p2=topPts[(i+1)%topPts.length], p3=botPts[(i+1)%botPts.length], p4=botPts[i];
    sideBPoly.setAttribute('points', toStr([p1,p2,p3,p4]));
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
