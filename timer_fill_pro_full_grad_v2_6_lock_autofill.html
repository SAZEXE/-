<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>timer_fill_pro_full_grad — v2.6 (lock fills current resolution)</title>
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --text:#e9eef4; --muted:#94a3b8;
    --accent1:#4da3ff; --accent2:#8a7dff; --ring:#2b3140; --grid:#0f1220;
  }
  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:16px/1.5 -apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial,"Hiragino Sans","Noto Sans JP",sans-serif;
    display:grid; grid-template-rows:1fr auto; gap:10px;
  }
  header{
    display:flex; align-items:center; justify-content:center; gap:10px;
    padding:12px 14px; background:var(--panel); box-shadow:0 1px 0 rgba(255,255,255,.04) inset;
  }
  header h1{font-size:16px; margin:0; font-weight:600; opacity:.9;}
  main{display:grid; place-items:center; padding:0; margin:0;}
  canvas{width:100vw; height:100vh; touch-action:none; background:var(--grid); display:block;}
  .hud{
    position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
    background:var(--panel); border:1px solid #222834; border-radius:12px;
    padding:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  .hud input[type="number"]{width:6.2em;}
  .hud input,.hud button,.hud select,.hud label{ font:inherit; color:var(--text); }
  .hud input[type="number"], .hud input[type="color"], .hud select, .hud button{
    background:#1d2230; border:1px solid #2b3140; border-radius:10px;
    padding:8px 10px; outline:none;
  }
  .hud button{cursor:pointer;}
  .hud button.primary{background:linear-gradient(135deg,var(--accent1),var(--accent2)); border:none; font-weight:700;}
  .hud button.ghost{background:transparent; border-color:#2b3140; color:var(--muted);}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .small{font-size:.85em; color:var(--muted);}
  .ok{font-weight:700;}
  label.small{user-select:none;}
  .hide-in-fs{}
  :fullscreen .hide-in-fs{ display:none !important; }
  :fullscreen .hud{ display:none !important; }
  .group{padding:6px 8px; border:1px solid #2b3140; border-radius:10px; background:#151a26;}
</style>
</head>
<body>
  <header class="hide-in-fs">
    <h1>timer_fill_pro_full_grad — v2.6</h1>
    <span class="small">スキャンライン / 全画面塗り切り / 時刻ベース（スリープ復帰）</span>
  </header>

  <main>
    <canvas id="cv" width="700" height="700" aria-label="タイマー表示（スキャンライン）"></canvas>
  </main>

  <div class="hud" role="group" aria-label="操作">
    <div class="row group">
      <span class="small">① 時間指定：</span>
      <input id="dh" type="number" min="0" step="1" value="0" aria-label="時間" />時間
      <input id="dm" type="number" min="0" step="1" value="1" aria-label="分" />分
      <input id="ds" type="number" min="0" step="1" value="0" aria-label="秒" />秒
      <button id="startDur" class="primary">Start（この時間で塗り切り）</button>
    </div>

    <div class="row group">
      <span class="small">② 終了時刻：</span>
      <input id="th" type="number" min="0" max="23" step="1" value="" placeholder="時" style="width:5.5em" />時
      <input id="tm" type="number" min="0" max="59" step="1" value="" placeholder="分" style="width:5.5em" />分
      <button id="startClock" class="ghost">Start（この時刻に塗り切る）</button>
      <span class="small">※ 過ぎていれば翌日扱いで記録</span>
    </div>

    <div class="row group">
      <label class="small">グラデ：</label>
      <input id="c1" type="color" value="#4da3ff" title="開始色" />
      <input id="c2" type="color" value="#8a7dff" title="終了色" />
      <label class="small">角度(°)：</label>
      <input id="angle" type="number" min="0" max="360" step="1" value="45" style="width:6em" />
    </div>

    <div class="row group">
      <label class="small">横(px)：</label>
      <input id="wpx" type="number" min="1" step="1" value="0" title="内部横ピクセル（0=自動）" />
      <label class="small">縦(px)：</label>
      <input id="hpx" type="number" min="1" step="1" value="0" title="内部縦ピクセル（0=自動）" />
      <label class="small">固定：</label>
      <input id="lockRes" type="checkbox" />
      <button id="applyRes" class="ghost">解像度適用</button>
    </div>

    <div class="row">
      <button id="fs" class="ghost">全画面</button>
      <button id="pause" class="ghost">Pause</button>
      <button id="reset" class="ghost">Reset</button>
      <span class="small">進捗：<span id="pct" class="ok">0%</span></span>
      <span class="small">総ピクセル：<span id="total" class="ok">-</span></span>
      <span class="small">モード：<span id="mode" class="ok">duration</span></span>
      <span class="small">終了予定：<span id="endinfo" class="ok">-</span></span>
    </div>
  </div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:true });
  const $ = sel => document.querySelector(sel);

  // ===== 状態 =====
  let durationMs  = 60_000;      // この時間で全画面を塗り切る
  let startTime   = null;        // ms since epoch
  let pausedSum   = 0;           // 合計一時停止時間
  let pauseAt     = null;        // 一時停止中なら開始時刻
  let rafId       = null;

  // Gradient settings
  let gradC1 = '#4da3ff';
  let gradC2 = '#8a7dff';
  let gradAngleDeg = 45;

  // Resolution settings
  let lockRes = false;  // true = use fixed internal resolution
  let fixedW = 0;       // internal width in pixels (0 = auto)
  let fixedH = 0;

  // Mode
  let mode = 'duration';  // 'duration' or 'clock'
  let lastClock = null;   // {hh, mm, targetEpochMs}

  const KEY = 'timer_fill_state_v26';
  const KEY_CFG = 'timer_fill_cfg_v26';

  // ===== ユーティリティ =====
  const clamp01 = x => x < 0 ? 0 : x > 1 ? 1 : x;
  const now = () => Date.now();
  function fmtRemain(tms) {
    const s = Math.max(0, Math.ceil(tms / 1000));
    const m = Math.floor(s / 60);
    const h = Math.floor(m / 60);
    const mm = m % 60, ss = String(s % 60).padStart(2, '0');
    return h ? `${h}:${String(mm).padStart(2,'0')}:${ss}` : `${mm}:${ss}`;
  }
  function withComma(n){ return n.toLocaleString('en-US'); }

  function progressNow() {
    if (startTime == null) return 0;
    const extra = pauseAt ? (now() - pauseAt) : 0;
    return clamp01((now() - startTime - (pausedSum + extra)) / durationMs);
  }

  // ===== グラデ計算 =====
  function makeLinearGradient(ctx, angleDeg){
    const rad = (angleDeg % 360) * Math.PI / 180;
    const ux = Math.cos(rad), uy = Math.sin(rad);
    const cx = cv.width / 2, cy = cv.height / 2;
    const L = Math.hypot(cv.width, cv.height) / 2;
    const x0 = cx - ux * L, y0 = cy - uy * L;
    const x1 = cx + ux * L, y1 = cy + uy * L;
    const g = ctx.createLinearGradient(x0, y0, x1, y1);
    g.addColorStop(0, gradC1);
    g.addColorStop(1, gradC2);
    return g;
  }

  // ===== 描画（スキャンライン） =====
  function drawScanlineByProgress(p) {
    ctx.clearRect(0,0,cv.width,cv.height);

    const W = cv.width | 0;
    const H = cv.height | 0;
    const total = (W * H) | 0;
    $('#total').textContent = withComma(total);

    const filled = Math.floor(total * clamp01(p));

    // グラデ
    const grad = makeLinearGradient(ctx, gradAngleDeg);
    ctx.fillStyle = grad;

    const fullRows = Math.floor(filled / W);
    const rem = filled - fullRows * W;

    if (fullRows > 0) ctx.fillRect(0, 0, W, fullRows);
    if (rem > 0 && fullRows < H) ctx.fillRect(0, fullRows, rem, 1);

    // 右上表示（残り時間＋%）
    const remain = durationMs * (1 - progressNow());
    const pct = Math.round(clamp01(p)*100);

    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';

    // 時間
    const baseFont = Math.round(Math.min(cv.width, cv.height)*0.06);
    ctx.font = `${baseFont}px system-ui, -apple-system`;
    const x = cv.width - 12, y = 10;
    ctx.fillText(fmtRemain(remain), x, y);

    // %（少し小さめで下に）
    ctx.font = `${Math.max(10, Math.round(baseFont*0.75))}px system-ui, -apple-system`;
    ctx.fillText(`${pct}%`, x, y + baseFont * 1.05);
  }

  function draw() {
    const p = progressNow();
    drawScanlineByProgress(p);
    if (p < 1) rafId = requestAnimationFrame(draw); else rafId = null;
  }
  function kick(){ if (rafId) cancelAnimationFrame(rafId); draw(); }

  // ===== 状態保存 =====
  function save() {
    const payload = { durationMs, startTime, pausedSum, pauseAt:null, mode, lastClock };
    localStorage.setItem(KEY, JSON.stringify(payload));
    const cfg = {gradC1,gradC2,gradAngleDeg,lockRes,fixedW,fixedH};
    localStorage.setItem(KEY_CFG, JSON.stringify(cfg));
  }
  function restore() {
    const raw = localStorage.getItem(KEY);
    if (raw) {
      try {
        const s = JSON.parse(raw);
        durationMs = s.durationMs ?? durationMs;
        startTime  = s.startTime  ?? null;
        pausedSum  = s.pausedSum  ?? 0;
        pauseAt    = null;
        mode       = s.mode ?? mode;
        lastClock  = s.lastClock ?? lastClock;
      } catch {}
    }
    const raw2 = localStorage.getItem(KEY_CFG);
    if (raw2) {
      try {
        const c = JSON.parse(raw2);
        gradC1 = c.gradC1 ?? gradC1;
        gradC2 = c.gradC2 ?? gradC2;
        gradAngleDeg = c.gradAngleDeg ?? gradAngleDeg;
        lockRes = !!c.lockRes;
        fixedW = c.fixedW ?? fixedW;
        fixedH = c.fixedH ?? fixedH;
      } catch {}
    }
    // 反映
    $('#c1').value = gradC1;
    $('#c2').value = gradC2;
    $('#angle').value = gradAngleDeg;
    $('#lockRes').checked = lockRes;
    $('#wpx').value = fixedW || 0;
    $('#hpx').value = fixedH || 0;
    $('#mode').textContent = mode;
    if (lastClock && lastClock.hh != null) {
      $('#th').value = lastClock.hh;
      $('#tm').value = lastClock.mm;
      updateEndInfo(lastClock.targetEpochMs);
    }
  }

  // ===== API =====
  const API = {
    startDuration(h, m, s){
      const secs = Math.max(0.1, (Number(h)||0)*3600 + (Number(m)||0)*60 + (Number(s)||0));
      durationMs = secs * 1000;
      startTime = now(); pausedSum = 0; pauseAt = null;
      mode = 'duration'; lastClock = null; save();
      updateModeLabel();
      updateEndInfo(startTime + durationMs);
      kick(); updatePauseBtn();
    },
    startClock(hh, mm){
      const d = new Date();
      d.setSeconds(0,0);
      d.setHours(Number(hh)||0, Number(mm)||0, 0, 0);
      if (d.getTime() <= now()) d.setDate(d.getDate() + 1);
      startTime = now(); pausedSum = 0; pauseAt = null;
      durationMs = Math.max(100, d.getTime() - startTime);
      mode = 'clock'; lastClock = {hh: Number(hh)||0, mm: Number(mm)||0, targetEpochMs: d.getTime()};
      save();
      updateModeLabel();
      updateEndInfo(d.getTime());
      kick(); updatePauseBtn();
    },
    pause(){
      if (!startTime || pauseAt) return;
      pauseAt = now(); save(); updatePauseBtn();
    },
    resume(){
      if (!startTime || !pauseAt) return;
      pausedSum += now() - pauseAt; pauseAt = null; save(); kick(); updatePauseBtn();
    },
    togglePause(){
      if (!startTime) return;
      if (pauseAt) API.resume(); else API.pause();
    },
    reset(){
      startTime = null; pausedSum = 0; pauseAt = null;
      save(); kick(); updatePauseBtn();
    },
    progress: () => progressNow()
  };
  window.timerFill = API;

  // ===== イベント =====
  function updatePauseBtn(){
    const b = $('#pause');
    if (!startTime){ b.textContent = 'Pause'; b.disabled = true; return; }
    b.disabled = false;
    b.textContent = pauseAt ? 'Resume' : 'Pause';
  }
  function updateModeLabel(){ $('#mode').textContent = mode; }
  function updateEndInfo(epoch){
    if (!epoch){ $('#endinfo').textContent = '-'; return; }
    const d = new Date(epoch);
    const mm = String(d.getMinutes()).padStart(2,'0');
    const hh = String(d.getHours()).padStart(2,'0');
    const md = `${d.getMonth()+1}/${d.getDate()}`;
    $('#endinfo').textContent = `${md} ${hh}:${mm}`;
  }

  // Buttons
  $('#startDur').addEventListener('click', () => {
    API.startDuration($('#dh').value, $('#dm').value, $('#ds').value);
  });
  $('#startClock').addEventListener('click', () => {
    const hh = $('#th').value, mm = $('#tm').value;
    if (hh === '' || mm === '') return;
    API.startClock(hh, mm);
  });
  $('#pause').addEventListener('click', () => API.togglePause());
  $('#reset').addEventListener('click', () => API.reset());

  // Gradient inputs
  $('#c1').addEventListener('input', e => { gradC1 = e.target.value; save(); kick(); });
  $('#c2').addEventListener('input', e => { gradC2 = e.target.value; save(); kick(); });
  $('#angle').addEventListener('change', e => { gradAngleDeg = parseFloat(e.target.value)||0; save(); kick(); });

  // Resolution controls
  function fillInputsWithCurrentResolution(){
    $('#wpx').value = cv.width;
    $('#hpx').value = cv.height;
  }
  $('#lockRes').addEventListener('change', () => {
    const checked = $('#lockRes').checked;
    if (checked) {
      // いまの内部解像度をそのまま入力欄に入れて見える化
      fillInputsWithCurrentResolution();
    } else {
      // 自動に戻すときは数字は残してもOK。適用時に自動へ戻す。
    }
    save();
  });
  $('#applyRes').addEventListener('click', () => {
    lockRes = $('#lockRes').checked;
    if (lockRes) {
      // 未入力なら現在解像度で埋める
      if (!$('#wpx').value || !$('#hpx').value) fillInputsWithCurrentResolution();
      fixedW = Math.max(1, parseInt($('#wpx').value||String(cv.width),10));
      fixedH = Math.max(1, parseInt($('#hpx').value||String(cv.height),10));
    } else {
      fixedW = 0;
      fixedH = 0;
    }
    save();
    onResize(true);
  });

  // Fullscreen
  $('#fs').addEventListener('click', async () => {
    try{
      if (!document.fullscreenElement) {
        await document.documentElement.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    }catch(e){ console.warn(e); }
  });
  document.addEventListener('fullscreenchange', () => onResize(false));

  // リサイズ: 自動=画面×DPR／固定=指定解像度
  function onResize(){
    if (lockRes && fixedW>0 && fixedH>0) {
      cv.width = fixedW;
      cv.height = fixedH;
    } else {
      const dpr = Math.max(1, Math.min(4, window.devicePixelRatio || 1));
      cv.width = Math.max(1, Math.round(window.innerWidth * dpr));
      cv.height = Math.max(1, Math.round(window.innerHeight * dpr));
    }
    kick();
  }
  addEventListener('resize', onResize);

  addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') kick(); });
  addEventListener('pageshow', kick);
  addEventListener('beforeunload', save);

  // 初期化
  (function init(){
    restore();
    onResize();
    updatePauseBtn();
    // 既に固定ONで保存されていたのに fixedW/H が0なら、現在解像度で埋めて保存
    if (lockRes && (!fixedW || !fixedH)) {
      fillInputsWithCurrentResolution();
      fixedW = cv.width; fixedH = cv.height;
      save();
    }
  })();
})();
</script>
</body>
</html>
